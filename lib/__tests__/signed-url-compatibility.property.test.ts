/**
 * Signed URL Compatibility Property-Based Tests
 * 
 * Feature: pdf-iframe-blocking-fix, Property 27: Signed URL compatibility
 * 
 * Property: For any generated signed URL, PDF.js should be able to fetch the PDF successfully
 * 
 * Validates: Requirements 8.3
 * 
 * These property-based tests verify that signed URLs generated by the system
 * are compatible with PDF.js fetch requests across various scenarios.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fc from 'fast-check';
import { loadPDFDocument } from '../pdfjs-integration';

// Mock the storage module
vi.mock('../storage', () => ({
  getSignedUrl: vi.fn(),
  getBucketForContentType: vi.fn(),
  uploadFile: vi.fn(),
  downloadFile: vi.fn(),
  deleteFile: vi.fn(),
  getPublicUrl: vi.fn(),
  listFiles: vi.fn(),
}));

// Mock the network module
vi.mock('../pdfjs-network', () => ({
  optimizedFetch: vi.fn(),
}));

describe('Signed URL Compatibility - Property-Based Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Set up environment variables
    process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
    process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-key';
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  /**
   * Feature: pdf-iframe-blocking-fix, Property 27: Signed URL compatibility
   * 
   * Property: For any generated signed URL, PDF.js should be able to fetch the PDF successfully
   * 
   * Validates: Requirements 8.3
   * 
   * This property tests that signed URLs generated by the system can be successfully
   * fetched by PDF.js. The test verifies that:
   * 1. Signed URLs are properly formatted for fetch API
   * 2. Authentication tokens are correctly included
   * 3. PDF.js can successfully load documents from signed URLs
   * 4. The fetch process completes without CORS or authentication errors
   */
  describe('Property 27: Signed URL compatibility', () => {
    it('should successfully fetch PDFs from any generated signed URL', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate various document identifiers
          fc.record({
            userId: fc.uuid(),
            documentId: fc.uuid(),
            filename: fc.stringMatching(/^[a-zA-Z0-9_-]+\.pdf$/),
          }),
          // Generate expiration times (1 minute to 24 hours)
          fc.integer({ min: 60, max: 86400 }),
          async (pathData, expiresIn) => {
            const storagePath = `${pathData.userId}/${pathData.documentId}/${pathData.filename}`;
            
            // Generate a mock signed URL
            const mockSignedUrl = `https://test.supabase.co/storage/v1/object/sign/documents/${storagePath}?token=mock-token-${Date.now()}`;
            
            // Mock storage module to return signed URL
            const { getSignedUrl } = await import('../storage');
            vi.mocked(getSignedUrl).mockResolvedValue({
              url: mockSignedUrl,
              error: undefined,
            });
            
            // Create a minimal valid PDF (PDF header + minimal structure)
            const minimalPDF = new Uint8Array([
              0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a, // %PDF-1.4\n
              0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, // Binary comment
              0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, // 1 0 obj\n
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a, // <</Type/Catalog/Pages 2 0 R>>\n
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a, // endobj\n
              0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, // 2 0 obj\n
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x2f, 0x4b, 0x69, 0x64, 0x73, 0x5b, 0x33, 0x20, 0x30, 0x20, 0x52, 0x5d, 0x2f, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x31, 0x3e, 0x3e, 0x0a, // <</Type/Pages/Kids[3 0 R]/Count 1>>\n
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a, // endobj\n
              0x33, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, // 3 0 obj\n
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x36, 0x31, 0x32, 0x20, 0x37, 0x39, 0x32, 0x5d, 0x3e, 0x3e, 0x0a, // <</Type/Page/Parent 2 0 R/MediaBox[0 0 612 792]>>\n
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a, // endobj\n
              0x78, 0x72, 0x65, 0x66, 0x0a, // xref\n
              0x30, 0x20, 0x34, 0x0a, // 0 4\n
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66, 0x20, 0x0a, // 0000000000 65535 f \n
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x35, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a, // 0000000015 00000 n \n
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x34, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a, // 0000000074 00000 n \n
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x33, 0x38, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a, // 0000000138 00000 n \n
              0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a, // trailer\n
              0x3c, 0x3c, 0x2f, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x34, 0x2f, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a, // <</Size 4/Root 1 0 R>>\n
              0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66, 0x0a, // startxref\n
              0x32, 0x32, 0x38, 0x0a, // 228\n
              0x25, 0x25, 0x45, 0x4f, 0x46, 0x0a, // %%EOF\n
            ]);
            
            // Mock the network fetch to return the PDF
            const { optimizedFetch } = await import('../pdfjs-network');
            vi.mocked(optimizedFetch).mockResolvedValue(
              new Response(minimalPDF.buffer, {
                status: 200,
                statusText: 'OK',
                headers: new Headers({
                  'Content-Type': 'application/pdf',
                  'Content-Length': minimalPDF.length.toString(),
                  'Access-Control-Allow-Origin': '*',
                  'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',
                }),
              })
            );

            // Attempt to load PDF using PDF.js with the signed URL
            const result = await loadPDFDocument({
              source: mockSignedUrl,
              timeout: 5000,
            });
            
            // Verify PDF was successfully loaded
            expect(result).toBeDefined();
            expect(result.document).toBeDefined();
            expect(result.numPages).toBeGreaterThan(0);
            
            // Verify the signed URL was used
            expect(optimizedFetch).toHaveBeenCalledWith(
              mockSignedUrl,
              expect.objectContaining({
                timeout: 5000,
              })
            );
            
            // Verify the URL format is compatible with fetch API
            expect(mockSignedUrl).toMatch(/^https?:\/\//);
            expect(mockSignedUrl).toContain('token=');
            
            // Clean up
            result.document.destroy();
          }
        ),
        {
          numRuns: 100, // Run 100 iterations as specified in design
          verbose: true,
        }
      );
    });

    it('should handle signed URLs with various authentication tokens', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate document paths
          fc.uuid().map(id => `user/${id}/document.pdf`),
          // Generate various token formats
          fc.record({
            token: fc.string({ minLength: 32, maxLength: 128 }).map(s => 
              Buffer.from(s).toString('hex').substring(0, 64)
            ),
            expires: fc.integer({ min: Date.now(), max: Date.now() + 86400000 }),
          }),
          async (storagePath, authData) => {
            // Generate signed URL with authentication token
            const mockSignedUrl = `https://test.supabase.co/storage/v1/object/sign/documents/${storagePath}?token=${authData.token}&expires=${authData.expires}`;
            
            const { getSignedUrl } = await import('../storage');
            vi.mocked(getSignedUrl).mockResolvedValue({
              url: mockSignedUrl,
              error: undefined,
            });
            
            // Create minimal PDF
            const minimalPDF = new Uint8Array([
              0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a,
              0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,
              0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x2f, 0x4b, 0x69, 0x64, 0x73, 0x5b, 0x33, 0x20, 0x30, 0x20, 0x52, 0x5d, 0x2f, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x31, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x33, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x36, 0x31, 0x32, 0x20, 0x37, 0x39, 0x32, 0x5d, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x78, 0x72, 0x65, 0x66, 0x0a,
              0x30, 0x20, 0x34, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x35, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x34, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x33, 0x38, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a,
              0x3c, 0x3c, 0x2f, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x34, 0x2f, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66, 0x0a,
              0x32, 0x32, 0x38, 0x0a,
              0x25, 0x25, 0x45, 0x4f, 0x46, 0x0a,
            ]);
            
            const { optimizedFetch } = await import('../pdfjs-network');
            vi.mocked(optimizedFetch).mockResolvedValue(
              new Response(minimalPDF.buffer, {
                status: 200,
                headers: new Headers({
                  'Content-Type': 'application/pdf',
                  'Access-Control-Allow-Origin': '*',
                }),
              })
            );
            
            // Load PDF with signed URL
            const result = await loadPDFDocument({
              source: mockSignedUrl,
              timeout: 5000,
            });
            
            // Verify successful load
            expect(result.document).toBeDefined();
            expect(result.numPages).toBeGreaterThan(0);
            
            // Verify token is present in URL
            expect(mockSignedUrl).toContain(`token=${authData.token}`);
            expect(mockSignedUrl).toContain(`expires=${authData.expires}`);
            
            // Clean up
            result.document.destroy();
          }
        ),
        {
          numRuns: 100,
          verbose: true,
        }
      );
    });


    it('should ensure signed URLs work with PDF.js fetch across different expiration times', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate storage paths
          fc.record({
            userId: fc.uuid(),
            documentId: fc.uuid(),
          }).map(ids => `${ids.userId}/${ids.documentId}/document.pdf`),
          // Generate various expiration times (1 minute to 7 days)
          fc.integer({ min: 60, max: 604800 }),
          async (storagePath, expiresIn) => {
            const expiresAt = Date.now() + (expiresIn * 1000);
            const mockSignedUrl = `https://test.supabase.co/storage/v1/object/sign/documents/${storagePath}?token=test-token&expires=${expiresAt}`;
            
            const { getSignedUrl } = await import('../storage');
            vi.mocked(getSignedUrl).mockResolvedValue({
              url: mockSignedUrl,
              error: undefined,
            });
            
            // Create minimal PDF
            const minimalPDF = new Uint8Array([
              0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a,
              0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,
              0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x2f, 0x4b, 0x69, 0x64, 0x73, 0x5b, 0x33, 0x20, 0x30, 0x20, 0x52, 0x5d, 0x2f, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x31, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x33, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x36, 0x31, 0x32, 0x20, 0x37, 0x39, 0x32, 0x5d, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x78, 0x72, 0x65, 0x66, 0x0a,
              0x30, 0x20, 0x34, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x35, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x34, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x33, 0x38, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a,
              0x3c, 0x3c, 0x2f, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x34, 0x2f, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66, 0x0a,
              0x32, 0x32, 0x38, 0x0a,
              0x25, 0x25, 0x45, 0x4f, 0x46, 0x0a,
            ]);
            
            const { optimizedFetch } = await import('../pdfjs-network');
            vi.mocked(optimizedFetch).mockResolvedValue(
              new Response(minimalPDF.buffer, {
                status: 200,
                headers: new Headers({
                  'Content-Type': 'application/pdf',
                  'Access-Control-Allow-Origin': '*',
                }),
              })
            );
            
            // Load PDF
            const result = await loadPDFDocument({
              source: mockSignedUrl,
              timeout: 5000,
            });
            
            // Verify successful load
            expect(result.document).toBeDefined();
            expect(result.numPages).toBeGreaterThan(0);
            
            // Verify expiration is in the future
            expect(expiresAt).toBeGreaterThan(Date.now());
            
            // Clean up
            result.document.destroy();
          }
        ),
        {
          numRuns: 100,
          verbose: true,
        }
      );
    });

    it('should ensure signed URLs include proper download flag for fetch compatibility', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate document paths
          fc.uuid().map(id => `documents/${id}.pdf`),
          async (storagePath) => {
            const mockSignedUrl = `https://test.supabase.co/storage/v1/object/sign/documents/${storagePath}?token=test-token`;
            
            const { getSignedUrl } = await import('../storage');
            vi.mocked(getSignedUrl).mockResolvedValue({
              url: mockSignedUrl,
              error: undefined,
            });
            
            // Generate signed URL with download flag set to false
            const result = await getSignedUrl(storagePath, 3600, 'documents', {
              download: false, // Critical for fetch API compatibility
            });
            
            expect(result.url).toBeDefined();
            expect(result.error).toBeUndefined();
            
            // Verify the signed URL was created with correct parameters
            expect(getSignedUrl).toHaveBeenCalledWith(
              storagePath,
              3600,
              'documents',
              expect.objectContaining({
                download: false, // Ensures fetch API compatibility
              })
            );
            
            // Create minimal PDF
            const minimalPDF = new Uint8Array([
              0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a,
              0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,
              0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x2f, 0x4b, 0x69, 0x64, 0x73, 0x5b, 0x33, 0x20, 0x30, 0x20, 0x52, 0x5d, 0x2f, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x31, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x33, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x36, 0x31, 0x32, 0x20, 0x37, 0x39, 0x32, 0x5d, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x78, 0x72, 0x65, 0x66, 0x0a,
              0x30, 0x20, 0x34, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x35, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x34, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x33, 0x38, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a,
              0x3c, 0x3c, 0x2f, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x34, 0x2f, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66, 0x0a,
              0x32, 0x32, 0x38, 0x0a,
              0x25, 0x25, 0x45, 0x4f, 0x46, 0x0a,
            ]);
            
            const { optimizedFetch } = await import('../pdfjs-network');
            vi.mocked(optimizedFetch).mockResolvedValue(
              new Response(minimalPDF.buffer, {
                status: 200,
                headers: new Headers({
                  'Content-Type': 'application/pdf',
                  'Content-Disposition': 'inline', // Not 'attachment' - allows fetch
                  'Access-Control-Allow-Origin': '*',
                }),
              })
            );
            
            // Load PDF using the signed URL
            const loadResult = await loadPDFDocument({
              source: mockSignedUrl,
              timeout: 5000,
            });
            
            // Verify successful load
            expect(loadResult.document).toBeDefined();
            expect(loadResult.numPages).toBeGreaterThan(0);
            
            // Verify Content-Disposition is inline (not attachment)
            // This is critical for fetch API compatibility
            const response = await optimizedFetch(mockSignedUrl, {});
            expect(response.headers.get('Content-Disposition')).toBe('inline');
            
            // Clean up
            loadResult.document.destroy();
          }
        ),
        {
          numRuns: 100,
          verbose: true,
        }
      );
    });


    it('should ensure signed URLs work with PDF.js across different bucket configurations', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate various bucket names
          fc.constantFrom('documents', 'pdfs', 'files', 'media'),
          // Generate storage paths
          fc.record({
            userId: fc.uuid(),
            documentId: fc.uuid(),
          }).map(ids => `${ids.userId}/${ids.documentId}/doc.pdf`),
          async (bucketName, storagePath) => {
            const mockSignedUrl = `https://test.supabase.co/storage/v1/object/sign/${bucketName}/${storagePath}?token=test-token`;
            
            const { getSignedUrl } = await import('../storage');
            vi.mocked(getSignedUrl).mockResolvedValue({
              url: mockSignedUrl,
              error: undefined,
            });
            
            // Create minimal PDF
            const minimalPDF = new Uint8Array([
              0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a,
              0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,
              0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x2f, 0x4b, 0x69, 0x64, 0x73, 0x5b, 0x33, 0x20, 0x30, 0x20, 0x52, 0x5d, 0x2f, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x31, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x33, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x36, 0x31, 0x32, 0x20, 0x37, 0x39, 0x32, 0x5d, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x78, 0x72, 0x65, 0x66, 0x0a,
              0x30, 0x20, 0x34, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x35, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x34, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x33, 0x38, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a,
              0x3c, 0x3c, 0x2f, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x34, 0x2f, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66, 0x0a,
              0x32, 0x32, 0x38, 0x0a,
              0x25, 0x25, 0x45, 0x4f, 0x46, 0x0a,
            ]);
            
            const { optimizedFetch } = await import('../pdfjs-network');
            vi.mocked(optimizedFetch).mockResolvedValue(
              new Response(minimalPDF.buffer, {
                status: 200,
                headers: new Headers({
                  'Content-Type': 'application/pdf',
                  'Access-Control-Allow-Origin': '*',
                }),
              })
            );
            
            // Load PDF from signed URL
            const result = await loadPDFDocument({
              source: mockSignedUrl,
              timeout: 5000,
            });
            
            // Verify successful load regardless of bucket
            expect(result.document).toBeDefined();
            expect(result.numPages).toBeGreaterThan(0);
            
            // Verify bucket name is in URL
            expect(mockSignedUrl).toContain(`/${bucketName}/`);
            
            // Clean up
            result.document.destroy();
          }
        ),
        {
          numRuns: 100,
          verbose: true,
        }
      );
    });

    it('should ensure signed URLs remain valid for PDF.js fetch throughout their lifetime', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate document paths
          fc.uuid().map(id => `user/${id}/document.pdf`),
          // Generate short expiration times to test validity
          fc.integer({ min: 60, max: 300 }), // 1-5 minutes
          async (storagePath, expiresIn) => {
            const expiresAt = Date.now() + (expiresIn * 1000);
            const mockSignedUrl = `https://test.supabase.co/storage/v1/object/sign/documents/${storagePath}?token=test-token&expires=${expiresAt}`;
            
            const { getSignedUrl } = await import('../storage');
            vi.mocked(getSignedUrl).mockResolvedValue({
              url: mockSignedUrl,
              error: undefined,
            });
            
            // Create minimal PDF
            const minimalPDF = new Uint8Array([
              0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a,
              0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,
              0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x73, 0x2f, 0x4b, 0x69, 0x64, 0x73, 0x5b, 0x33, 0x20, 0x30, 0x20, 0x52, 0x5d, 0x2f, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x31, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x33, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a,
              0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x36, 0x31, 0x32, 0x20, 0x37, 0x39, 0x32, 0x5d, 0x3e, 0x3e, 0x0a,
              0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a,
              0x78, 0x72, 0x65, 0x66, 0x0a,
              0x30, 0x20, 0x34, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x66, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x35, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x34, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x33, 0x38, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x6e, 0x20, 0x0a,
              0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a,
              0x3c, 0x3c, 0x2f, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x34, 0x2f, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x3e, 0x3e, 0x0a,
              0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66, 0x0a,
              0x32, 0x32, 0x38, 0x0a,
              0x25, 0x25, 0x45, 0x4f, 0x46, 0x0a,
            ]);
            
            const { optimizedFetch } = await import('../pdfjs-network');
            vi.mocked(optimizedFetch).mockResolvedValue(
              new Response(minimalPDF.buffer, {
                status: 200,
                headers: new Headers({
                  'Content-Type': 'application/pdf',
                  'Access-Control-Allow-Origin': '*',
                }),
              })
            );
            
            // Verify URL is currently valid (not expired)
            const currentTime = Date.now();
            expect(expiresAt).toBeGreaterThan(currentTime);
            
            // Load PDF while URL is valid
            const result = await loadPDFDocument({
              source: mockSignedUrl,
              timeout: 5000,
            });
            
            // Verify successful load
            expect(result.document).toBeDefined();
            expect(result.numPages).toBeGreaterThan(0);
            
            // Verify the URL is still valid after loading
            expect(expiresAt).toBeGreaterThan(Date.now());
            
            // Clean up
            result.document.destroy();
          }
        ),
        {
          numRuns: 100,
          verbose: true,
        }
      );
    });
  });
});
