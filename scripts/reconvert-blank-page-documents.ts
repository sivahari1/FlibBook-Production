#!/usr/bin/env tsx
/**
 * Reconvert Documents with Blank Pages
 * 
 * This script reconverts documents that have been identified as having blank pages.
 * It reads from the blank-page-documents.json file generated by identify-blank-page-documents.ts
 * and triggers reconversion for each document in batches.
 * 
 * Usage: npm run reconvert-blank-pages [--batch-size=5] [--dry-run]
 * 
 * Options:
 *   --batch-size=N  Process N documents at a time (default: 5)
 *   --dry-run       Show what would be done without actually reconverting
 *   --document-id=ID  Reconvert a specific document by ID
 * 
 * Requirements: 1.1, 2.1
 */

import { createClient } from '@supabase/supabase-js';
import { prisma } from '@/lib/db';
import { logger } from '@/lib/logger';
import { convertPdfToImages } from '@/lib/services/pdf-converter';
import fs from 'fs/promises';
import fsSync from 'fs';
import path from 'path';

// Initialize Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

interface BlankPageDocument {
  documentId: string;
  filename: string;
  userId: string;
  averageSizeKB: number;
  suspiciousPages: number;
  pageCount: number;
}

interface ReconversionResult {
  documentId: string;
  filename: string;
  success: boolean;
  error?: string;
  oldAverageSizeKB?: number;
  newAverageSizeKB?: number;
  pageCount?: number;
  conversionTimeMs?: number;
}

/**
 * Load documents from the exported JSON file
 */
function loadBlankPageDocuments(): BlankPageDocument[] {
  const filePath = path.join(process.cwd(), 'blank-page-documents.json');
  
  if (!fsSync.existsSync(filePath)) {
    console.error('‚ùå blank-page-documents.json not found!');
    console.log('   Run: npm run identify-blank-pages first');
    process.exit(1);
  }

  const data = fsSync.readFileSync(filePath, 'utf-8');
  return JSON.parse(data);
}

/**
 * Delete existing page images for a document
 */
async function deleteExistingPages(userId: string, documentId: string): Promise<boolean> {
  try {
    // List all existing page files
    const { data: files, error: listError } = await supabase.storage
      .from('document-pages')
      .list(`${userId}/${documentId}`);

    if (listError) {
      logger.error(`Failed to list pages for deletion:`, listError);
      return false;
    }

    if (!files || files.length === 0) {
      logger.info(`No existing pages to delete for document ${documentId}`);
      return true;
    }

    // Delete all page files
    const filePaths = files.map(f => `${userId}/${documentId}/${f.name}`);
    const { error: deleteError } = await supabase.storage
      .from('document-pages')
      .remove(filePaths);

    if (deleteError) {
      logger.error(`Failed to delete existing pages:`, deleteError);
      return false;
    }

    logger.info(`Deleted ${files.length} existing page files`);
    return true;
  } catch (error) {
    logger.error(`Error deleting existing pages:`, error);
    return false;
  }
}

/**
 * Reconvert a single document
 */
async function reconvertDocument(doc: BlankPageDocument): Promise<ReconversionResult> {
  const startTime = Date.now();
  let newAverageSizeKB = 0;
  let pageCount = 0;
  
  try {
    console.log(`\nüìÑ Reconverting: ${doc.filename}`);
    console.log(`   Document ID: ${doc.documentId}`);
    console.log(`   Old average size: ${doc.averageSizeKB.toFixed(2)} KB`);
    console.log(`   Suspicious pages: ${doc.suspiciousPages}/${doc.pageCount}`);

    // Get document from database
    const document = await prisma.document.findUnique({
      where: { id: doc.documentId },
      select: {
        id: true,
        userId: true,
        storagePath: true,
        filename: true,
      },
    });

    if (!document) {
      throw new Error('Document not found in database');
    }

    // Download PDF from storage
    console.log('   üì• Downloading PDF from storage...');
    const { data: pdfData, error: downloadError } = await supabase.storage
      .from('documents')
      .download(document.storagePath);

    if (downloadError || !pdfData) {
      throw new Error(`Failed to download PDF: ${downloadError?.message}`);
    }

    // Convert Blob to Buffer and write to temp file
    const arrayBuffer = await pdfData.arrayBuffer();
    const pdfBuffer = Buffer.from(arrayBuffer);
    console.log(`   ‚úÖ Downloaded PDF (${(pdfBuffer.length / 1024).toFixed(2)} KB)`);

    // Create temp directory and write PDF
    const tempDir = await fs.mkdtemp(path.join(require('os').tmpdir(), 'reconvert-'));
    const pdfPath = path.join(tempDir, 'document.pdf');
    await fs.writeFile(pdfPath, pdfBuffer);

    try {
      // Delete existing pages
      console.log('   üóëÔ∏è  Deleting existing page images...');
      const deleted = await deleteExistingPages(document.userId, document.id);
      if (!deleted) {
        throw new Error('Failed to delete existing pages');
      }

      // Delete existing DocumentPage records
      await prisma.documentPage.deleteMany({
        where: { documentId: document.id },
      });

      // Reconvert PDF to images
      console.log('   üîÑ Converting PDF to images...');
      const result = await convertPdfToImages({
        documentId: document.id,
        userId: document.userId,
        pdfPath,
        quality: 85,
        dpi: 150,
        format: 'jpg',
      });

      if (!result.success) {
        throw new Error(result.error || 'Conversion failed');
      }

      // Get new page statistics from database
      const pages = await prisma.documentPage.findMany({
        where: { documentId: document.id },
        select: { fileSize: true },
      });

      const totalSize = pages.reduce((sum, p) => sum + p.fileSize, 0);
      newAverageSizeKB = totalSize / pages.length / 1024;
      pageCount = pages.length;
      const conversionTimeMs = Date.now() - startTime;

      console.log(`   ‚úÖ Conversion complete!`);
      console.log(`   üìä New average size: ${newAverageSizeKB.toFixed(2)} KB`);
      console.log(`   ‚è±Ô∏è  Conversion time: ${(conversionTimeMs / 1000).toFixed(2)}s`);

      // Check if reconversion was successful
      if (newAverageSizeKB < 10) {
        console.log(`   ‚ö†Ô∏è  WARNING: New average size still < 10 KB!`);
      } else {
        console.log(`   üéâ Success! Pages are no longer blank`);
      }

      return {
        documentId: doc.documentId,
        filename: doc.filename,
        success: true,
        oldAverageSizeKB: doc.averageSizeKB,
        newAverageSizeKB,
        pageCount,
        conversionTimeMs,
      };
    } finally {
      // Clean up temp directory
      await fs.rm(tempDir, { recursive: true, force: true });
    }

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.log(`   ‚ùå Failed: ${errorMessage}`);

    return {
      documentId: doc.documentId,
      filename: doc.filename,
      success: false,
      error: errorMessage,
      oldAverageSizeKB: doc.averageSizeKB,
    };
  }
}

/**
 * Process documents in batches
 */
async function processBatch(
  documents: BlankPageDocument[],
  batchSize: number,
  dryRun: boolean
): Promise<ReconversionResult[]> {
  const results: ReconversionResult[] = [];
  
  for (let i = 0; i < documents.length; i += batchSize) {
    const batch = documents.slice(i, i + batchSize);
    const batchNumber = Math.floor(i / batchSize) + 1;
    const totalBatches = Math.ceil(documents.length / batchSize);

    console.log('\n' + '='.repeat(80));
    console.log(`\nüì¶ Batch ${batchNumber}/${totalBatches} (${batch.length} documents)\n`);

    if (dryRun) {
      console.log('üîç DRY RUN - Would reconvert:');
      batch.forEach((doc, index) => {
        console.log(`   ${i + index + 1}. ${doc.filename} (${doc.documentId})`);
        console.log(`      Average: ${doc.averageSizeKB.toFixed(2)} KB`);
      });
      continue;
    }

    // Process batch sequentially to avoid overload
    for (const doc of batch) {
      const result = await reconvertDocument(doc);
      results.push(result);

      // Small delay between documents
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // Longer delay between batches
    if (i + batchSize < documents.length) {
      console.log('\n‚è∏Ô∏è  Pausing 5 seconds before next batch...');
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }

  return results;
}

/**
 * Main reconversion function
 */
async function reconvertBlankPageDocuments(): Promise<void> {
  // Parse command-line arguments
  const args = process.argv.slice(2);
  const batchSizeArg = args.find(arg => arg.startsWith('--batch-size='));
  const batchSize = batchSizeArg ? parseInt(batchSizeArg.split('=')[1]) : 5;
  const dryRun = args.includes('--dry-run');
  const documentIdArg = args.find(arg => arg.startsWith('--document-id='));
  const specificDocumentId = documentIdArg ? documentIdArg.split('=')[1] : null;

  console.log('üîÑ Reconverting Documents with Blank Pages');
  console.log('=' .repeat(80));
  console.log(`\nBatch size: ${batchSize}`);
  console.log(`Mode: ${dryRun ? 'DRY RUN' : 'LIVE'}`);

  // Load documents to reconvert
  let documents: BlankPageDocument[];
  
  if (specificDocumentId) {
    console.log(`\nTarget: Single document (${specificDocumentId})`);
    
    // Load all documents and filter for the specific one
    const allDocuments = loadBlankPageDocuments();
    const specificDoc = allDocuments.find(d => d.documentId === specificDocumentId);
    
    if (!specificDoc) {
      console.error(`\n‚ùå Document ${specificDocumentId} not found in blank-page-documents.json`);
      console.log('   Run: npm run identify-blank-pages first');
      process.exit(1);
    }
    
    documents = [specificDoc];
  } else {
    documents = loadBlankPageDocuments();
    console.log(`\nTarget: All documents (${documents.length} total)`);
  }

  if (documents.length === 0) {
    console.log('\n‚úÖ No documents to reconvert');
    return;
  }

  // Process documents
  const results = await processBatch(documents, batchSize, dryRun);

  if (dryRun) {
    console.log('\n' + '='.repeat(80));
    console.log('\n‚úÖ Dry run complete!');
    console.log(`\nTo actually reconvert, run: npm run reconvert-blank-pages`);
    return;
  }

  // Display results summary
  console.log('\n' + '='.repeat(80));
  console.log('\nüìä RECONVERSION SUMMARY\n');

  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);
  const stillBlank = successful.filter(r => r.newAverageSizeKB && r.newAverageSizeKB < 10);
  const fixed = successful.filter(r => r.newAverageSizeKB && r.newAverageSizeKB >= 10);

  console.log(`Total documents: ${results.length}`);
  console.log(`‚úÖ Successful: ${successful.length}`);
  console.log(`   üéâ Fixed: ${fixed.length}`);
  console.log(`   ‚ö†Ô∏è  Still blank: ${stillBlank.length}`);
  console.log(`‚ùå Failed: ${failed.length}`);

  if (successful.length > 0) {
    const totalTime = successful.reduce((sum, r) => sum + (r.conversionTimeMs || 0), 0);
    const avgTime = totalTime / successful.length;
    console.log(`\n‚è±Ô∏è  Average conversion time: ${(avgTime / 1000).toFixed(2)}s per document`);
  }

  // Display fixed documents
  if (fixed.length > 0) {
    console.log('\n' + '='.repeat(80));
    console.log('\nüéâ SUCCESSFULLY FIXED DOCUMENTS\n');
    fixed.forEach((result, index) => {
      console.log(`${index + 1}. ${result.filename}`);
      console.log(`   Before: ${result.oldAverageSizeKB?.toFixed(2)} KB`);
      console.log(`   After: ${result.newAverageSizeKB?.toFixed(2)} KB`);
      console.log(`   Improvement: ${((result.newAverageSizeKB! / result.oldAverageSizeKB! - 1) * 100).toFixed(0)}%`);
    });
  }

  // Display still blank documents
  if (stillBlank.length > 0) {
    console.log('\n' + '='.repeat(80));
    console.log('\n‚ö†Ô∏è  STILL BLANK AFTER RECONVERSION\n');
    console.log('These documents may have issues with the source PDF:\n');
    stillBlank.forEach((result, index) => {
      console.log(`${index + 1}. ${result.filename} (${result.documentId})`);
      console.log(`   Average size: ${result.newAverageSizeKB?.toFixed(2)} KB`);
    });
  }

  // Display failed documents
  if (failed.length > 0) {
    console.log('\n' + '='.repeat(80));
    console.log('\n‚ùå FAILED RECONVERSIONS\n');
    failed.forEach((result, index) => {
      console.log(`${index + 1}. ${result.filename} (${result.documentId})`);
      console.log(`   Error: ${result.error}`);
    });
  }

  // Export results
  const exportPath = 'reconversion-results.json';
  fsSync.writeFileSync(exportPath, JSON.stringify(results, null, 2));
  console.log(`\nüìÑ Exported results to: ${exportPath}`);

  console.log('\n' + '='.repeat(80));
}

/**
 * Main execution
 */
if (require.main === module) {
  reconvertBlankPageDocuments()
    .then(() => {
      console.log('\n‚úÖ Reconversion complete!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\nüí• Reconversion failed:', error);
      process.exit(1);
    });
}

export { reconvertBlankPageDocuments, reconvertDocument };
